<html>
<body>


<h1>Fiddling with the system's "@run{...}"</h1>


<p>"@run{...}" is the main primitive of XLIA systems, describing the evaluation model of machines in the system. It is called at each execution step of the system in a "top-down" manner: in the @run primitive, a machine calls (directly or not) the execution of its components via the instructions run or schedule.</p>
<p>In a model with state-transition machines, this primitive can be completely generated by Diversityâ€™s compiler according to semantical information given by the user (e.g. transition priorities).</p>

<h2>Example system</h2>
<p>Let us have a look at the following picture which describes the idea of a system :</p>
<img src="images/run_3_001.png" width=750, border="3">
<p>The implied behavior of this system is that :</p>
<ul>
<li>FIRSTLY  the machine A get input inA1 and produces its outputs</li>
<li>SECONDLY the machines B and C can (in concurrency) produce their outputs</li>
</ul>
<p>With XLIA, we'll try to write a system that behaves this way.</p>

<h2>Modeling using input and output conditions</h2>
<p>We can model the system described above while respecting the implied execution order by carefully modeling input and output ports, producing transitions conditions on those inputs and outputs and by connecting them. A possible implementation is the following :</p>
<img src="images/run_3_002.png" width=750, border="3">
<p>An exploration graph generated from this model is :</p>
<img src="images/run_3_003.png" width=950, border="3">
<p>We see that the execution of the system goes smoothly :</p>
<ul>
<li>the statemachine A starts it's work on the input from A1</li>
<li>the statemachine A finishes it's work and produces outputs outA1 and outA2</li>
<li>simultaneously, the machines B and C start their work</li>
<li>then we have two possible cases :
	<ul>
	<li>either the machine B finishes first (left branche)</li>
	<li>or the machine C finishes first (right branche)</li>
	</ul>
</li>
</ul> 
<p>Remark : in this case, we don't acknowledge the possibility that both the machines B and C finish their work at the same time. In practice, it is perfectly acceptable for continuous time systems (it is an established use for instance in the treatment of <a href="https://en.wikipedia.org/wiki/Continuous-time_Markov_chain">Continuous-time Markov chains</a> where two distincts events cannot be realized at the same time (<a href="http://www.math-evry.cnrs.fr/_media/members/mfalconnet/chainemarkov2.pdf">a source</a>)).</p>


<h2>Modeling using the system's "@moe:@run{...}"</h2>
<p>We can make an equivalent model this time using the system's "@moe:@run{...}". To do that :</p>
<ul>
<li>we'll ignore all the inputs and outputs and the corresponding guards on the transitions</li>
<li>we'll remove the "final" flags on the 'done' states because they would stop the system's exploration prematurely</li>
<li>by default, if we declare a state without body or without transition, there is an implicit transition to itself that always succeeds. But we don't want that. So we write a transition that always fails with "guard(false);"</li>
<li>this transition that always fails will allow us to use <a href="../5_ordop/ordop_0.html">Order Operators</a></li>
<li>we implement the "@moe:@run{...}" as follows :</li>
</ul>
<img src="images/run_3_004.png" width=750, border="3">
<p>Explanation :</p>
<ul>
<li>the "|>|" operator will make the statemachine A execute and nothing else until the statemachine A reaches the "done" state</li>
<li>indeed, in the "done" state, A can only escape through the "t_a_d" transition that always fails</li>
<li>therefore, for the rest of the execution, the "|>|" operator will execute the right expression : {|i| {|;| run B; run B;} {|;| run C; run C;} }</li>
<li>the "|i|" operator will explore two paths :
	<ul>
	<li>{|;| run B; run B;} then {|;| run C; run C;}</li>
	<li>{|;| run C; run C;} then {|;| run B; run B;}</li>
	</ul>
</li>
<li>{|;| run B; run B;} exploring the "working" and "done" states of B</li>
<li>{|;| run C; run C;} exploring the "working" and "done" states of C</li>
</ul>

<p>As a consequence, we have the same exploration as the one we've got by expressing the model with conditions on the transitions :</p>
<img src="images/run_3_005.png" width=750, border="3">
<p>As we can see, this method requires a less complex XLIA code.</p>

<h2>Conclusion</h2>
<p>This example showed that there can be an equivalence between a flow of execution defined by transition guards and a flow of execution defined in the @moe:@run{...}</p>
<p></p>
</body>
</html>