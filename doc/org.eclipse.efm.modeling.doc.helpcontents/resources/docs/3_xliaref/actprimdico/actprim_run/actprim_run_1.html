<html>
<body>


<h1>Fiddling with a state's "@run{...}"</h1>


<p>A state's "@run{...}" primitive evaluates outgoing transitions of its container state, according to the associated semantics. But the expert user can add code to be evaluated before outgoing transitions.</p>

<p>One of the possible uses of the "@run{...}" primitive is that of writing instructions inside that ought to be executed just before the next choice of transition is made.</p>

<p>The <a href="../../4_examples/4_inefficientproject.html">Inefficient Project Workflow</a> example, is a prime example of this use of the "@run{...}" activity primitive. Indeed, for each "XTeamWorking" composite state, each time a substate transits to another, the "XTeamWorking"'s @run{...} is executed and therefore updates the workload of the Team. This is, among other things, useful for code factorization.</p>


<h1>Fiddling with a composite state's "@run{...}" : simple case</h1>

<h2>Theory</h2>
<p>When we have a composite state :</p>
<ul>
<li>with substates (of course because it is a composite state)</li>
<li>with NO outgoing transitions</li>
</ul>
<p>When we implement the @run{...} activity primitive and we put an instruction "action();" (which does not include "schedule" or "run" of the parent machine) inside such as below :</p>
<img src="images/run_1_001.png" width=500, border="3">
<p>The XLIA compiler interprets it as in the following :</p>
<img src="images/run_1_002.png" width=500, border="3">
<p>If what's inside "@run{...}" includes "run" or "schedule" instructions, it may replace the default "schedule self".</p>

<h2>Example</h2>
<p>Let's consider a LavaLamp statemachine. There are two ink drops; a red one and a blue one. The system describes a part of the lamp's cycle. Either one of the drop can fall from the top to the bottom.</p>

<p>The "blueDrop" is represented by a composite statemachine, as well as the "redDrop". In each of those, we'll be using the "@moe:@run{...}" in order to implement a counter, that will count the number of execution steps taken in the corresponding drop. The code is the following :</p>
<img src="images/run_1_003.png" width=750, border="3">
<p>The system's graph is the following :</p>
<img src="images/run_1_004.png" width=600, border="3">
<p>The exploration graph is the following; we can see the counters in action :</p>
<img src="images/run_1_005.png" width=1100, border="3">
<p>We notice that the counting starts after the "color_high" state is left. Indeed, it is because when entering the "colorDrop" composite state, we're not yet running it's inner "@run{...}" but the parent "LavaLamp"'s "@moe:@run{...}". Therefore, "run colorCounter" is not called.</p>




<h1>Fiddling with a composite state's "@run{...}" : complex case</h1>
<h2>Theory</h2>
<p>When we have a composite state :</p>
<ul>
<li>with substates (of course because it is a composite state)</li>
<li>with outgoing transitions</li>
</ul>
<p>When we implement the @run{...} activity primitive and we put an instruction "action();" (which does not include "schedule" or "run" of the parent machine) inside such as below :</p>
<img src="images/run_1_006.png" width=500, border="3">
<p>The XLIA compiler interprets it as in the following :</p>
<img src="images/run_1_007.png" width=500, border="3">
<p>If what's inside "@run{...}" includes "run" or "schedule" instructions, it may replace the default "schedule self".</p>
<p>We notice that the "action();" is not taken when evaluating outgoing transitions !!! We'll see how it can affect the system in the following example.</p>


<h2>Example</h2>

<p>Let's get back the exact same example used in "<a href="../actprim_irun/actprim_irun_1_3.html">composite state's "@irun{...}" : complex case</a>".</p>
<p>Here is the full exploration graph of the vanilla version :</p>
<img src="images/run_1_008.png" width=1100, border="3">
<p>Now, if we replace "irun" by "run" as the implemented primitive of the "gettingReady" composite state, the exploration graph becomes :</p>
<img src="images/run_1_009.png" width=1100, border="3">
<p>We see that when leaving the "gettingReady" state though the outoing transition "t_jump", the code "checkListItemsChecked ++;" is not executed anymore. This is due to the scheduling specificity that we've talked about in the theoretical part. This is also one of the differences between "run" and "irun".</p>

</body>
</html>